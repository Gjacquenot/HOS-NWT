MODULE definition2
!
! This module defines pseudo-objects for linear wave
! It allows computation of free waves generated by wavemaker (at use in wavemaking_HOS.f90)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!    Copyright (C) 2014 - LHEEA Lab., Ecole Centrale de Nantes, UMR CNRS 6598
!
!    This program is part of HOS-NWT
!
!    HOS-NWT is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
USE type
USE linear_wave, ONLY : wave_number_adim_r, alpha_adim_r
!
IMPLICIT NONE
!
INTEGER, PARAMETER :: summax = 1000
!
!
!
TYPE, PUBLIC :: size_basin
   ! Basin geometry
   REAL(RP) :: h
   REAL(RP) :: L_x
   REAL(RP) :: L_y
   ! Wavemaker geometry (hinged or piston)
   CHARACTER(lEN=10) :: type
   !    wavemaker hinged at distance 'd' from the bottom
   REAL(RP) :: d
   !    segmentation and number of flap
   LOGICAL  :: segmented
   INTEGER  :: N
   ! B600 geometry
   REAL(RP) :: L_r
   REAL(RP) :: L_l
   !
   CHARACTER(LEN=100)   :: path
   ! Variable for conv2D (test of convergence with number of first
   !                      order terms in 2D case)
   INTEGER              :: n_temp
END TYPE
!
!
!
TYPE, PUBLIC :: wave_12
   ! General data
   TYPE(size_basin)                         :: basin
   CHARACTER(LEN=9)                         :: wavemaker
   REAL(RP)                                 :: X_d
   REAL(RP)                                 :: prec
   CHARACTER(LEN=30)                        :: file
   CHARACTER(LEN=2)                         :: dimension
   ! First order
   REAL(RP)                                 :: freq
   COMPLEX(CP)                              :: ampli
   REAL(RP)                                 :: angle
   REAL(RP)                                 :: steepness
   ! Wavenumbers
   REAL(RP), POINTER, DIMENSION(:)          :: mu_n => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:)       :: alpha_m => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:,:)     :: k_mn => NULL( )
   ! Amplitudes
   COMPLEX(CP), POINTER, DIMENSION(:,:,:)   :: a_mn => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:,:,:)   :: TF_mn => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:)       :: a_on => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:,:)     :: TF_m => NULL( )
   COMPLEX(CP), POINTER, DIMENSION(:)       :: Inty_n => NULL( )
   ! Both order
   INTEGER, DIMENSION(2)                    :: n_mod_y,n_mod_z
   INTEGER, DIMENSION(2)                    :: N
   ! Second order
   REAL(RP)                                 :: freq2
   REAL(RP)                                 :: sumprec
   !    free wave
   !       wavenumbers
   COMPLEX(CP), POINTER, DIMENSION(:)       :: beta_m => NULL( )   ! = alpha2
   COMPLEX(CP), POINTER, DIMENSION(:,:)     :: gamma_mn => NULL( ) ! = k_mn2
   !       amplitudes
   COMPLEX(CP), POINTER, DIMENSION(:,:)     :: al_mn => NULL( )
   COMPLEX(CP)                              :: TF_f
   !    bound wave
   COMPLEX(CP), POINTER, DIMENSION(:,:,:,:) :: a_4p, a_4m => NULL( )
   COMPLEX(CP)                              :: a_s_2D 
   !
END TYPE
!
!
!
TYPE spectrum1
   TYPE(wave_12), POINTER, DIMENSION(:) :: wave => NULL( )
END TYPE
!
!
!
TYPE intro_var
   INTEGER                                   :: int_number
   INTEGER, POINTER, DIMENSION(:)            :: int_val
   CHARACTER(LEN=8), POINTER, DIMENSION(:)   :: int_name
   INTEGER                                   :: real_number
   REAL(RP), POINTER, DIMENSION(:)           :: real_val
   CHARACTER(LEN=8), POINTER, DIMENSION(:)   :: real_name
   CHARACTER(LEN=100), POINTER, DIMENSION(:) :: real_comment
END TYPE
!
!
!
INTERFACE ASSIGNMENT (=)
   MODULE PROCEDURE assign_wave12
END INTERFACE
!
INTERFACE ASSIGNMENT (=)
   MODULE PROCEDURE assign_spectrum1
END INTERFACE
!
INTERFACE OPERATOR (+)
   MODULE PROCEDURE add_wave12_to_spectrum1
END INTERFACE
!
!
!
CONTAINS
!
!
!
SUBROUTINE initialize_basin(basin,h,L_x,L_y,type,d,seg,N,L_r,L_l,path,n_temp)
!
IMPLICIT NONE
!
! Input variables
TYPE(size_basin), INTENT(OUT) :: basin
REAL(RP), INTENT(IN)          :: h,L_x,L_y,d,L_r,L_l
CHARACTER(LEN=*), INTENT(IN)  :: path, type
INTEGER, INTENT(IN)           :: N
LOGICAL, INTENT(IN)           :: seg
INTEGER, INTENT(IN)           :: n_temp
!
basin%h         = h
basin%L_x       = L_x
basin%L_y       = L_y
basin%type      = type
basin%d         = d
basin%segmented = seg
basin%N         = N
basin%L_r       = L_r
basin%L_l       = L_l
!
! Nondimensionalisation
!
basin%L_x = basin%L_x / h
basin%L_y = basin%L_y / h
basin%d   = basin%d   / h
basin%L_r = basin%L_r / h
basin%L_l = basin%L_l / h
!
basin%n_temp    = n_temp
basin%path      = path
!
END SUBROUTINE initialize_basin
!
!
!
SUBROUTINE initialize_wave1(wave, basin, freq, angle, ampli, phas, &
prec, dimension, case, steepness)
!
IMPLICIT NONE
!
! Input variables
TYPE(wave_12), INTENT(OUT)             :: wave
TYPE(size_basin)                       :: basin
REAL(RP), INTENT(IN)                   :: freq, angle, ampli, phas, prec
CHARACTER(LEN=2)                       :: dimension
CHARACTER(LEN=*), OPTIONAL             :: case
REAL(RP), INTENT(IN), OPTIONAL         :: steepness
! Local variables
REAL(RP)                               :: k
INTEGER                                :: n_mod_y, n_mod_z
!
CALL nullify_wave12(wave)
!
wave%freq      = freq
wave%prec      = prec
wave%angle     = angle
wave%basin     = basin
wave%dimension = dimension
k              = wave_number_adim_r(freq, prec)
IF (PRESENT(steepness)) THEN
   wave%steepness = steepness
   wave%ampli     = PI * steepness / k * EXP(i * phas) 
ELSE
   wave%steepness = k * ampli / PI
   wave%ampli     = ampli * EXP(i * phas)
END IF
!
! Tests on dimensions
IF ( dimension == '2D' ) THEN
   IF ( ABS(wave%basin%L_y) > tiny ) WRITE(*,'(A)') 'WARNING : L_y not equal to 0 in 2D case (initialise_wave12)'
   wave%N(1) = 0
ELSE IF ( dimension =='3D' ) THEN
   IF ( ABS(wave%basin%L_y) < tiny ) STOP 'L_y equal to 0 in 3D case (initialise_wave12)'
   wave%N(1) = FLOOR(k / PI * wave%basin%L_y)
ELSE
   WRITE(*,'(A)') 'Unknown dimension for dimension tests (initialise_wave12)'
END IF
!
! Dimension
IF ( dimension == '2D' ) THEN
   n_mod_z = 200 ! FLOOR(200* freq *SQRT(g/basin%h))
   n_mod_y = 0
ELSE IF ( dimension =='3D' ) THEN
   IF (PRESENT(case)) THEN
      IF ( case == 'free' ) THEN
    	n_mod_z = 40
      	n_mod_y = 10*wave%N(1)
   	  ELSE IF ( case == 'basin' ) THEN
        n_mod_z = 20
        n_mod_y = wave%N(1)
      ELSE IF ( case == 'target1' ) THEN
        n_mod_z = 20
        n_mod_y = 3*wave%N(1)
      ELSE
         WRITE(*,'(A)') 'Unknown case for size allocation'
      END IF
   ELSE
      n_mod_z = 0
      n_mod_y = 0
   END IF
ELSE
   WRITE(*,'(A)') 'Unknown dimension for size allocation'
END IF
!
wave%n_mod_z(1) = n_mod_z
wave%n_mod_y(1) = n_mod_y
!
END SUBROUTINE initialize_wave1
!
!
!
SUBROUTINE initialize_wave2(wave, case, sumprec)
!
IMPLICIT NONE
!
! Input variables 
TYPE(wave_12), INTENT(INOUT) :: wave
CHARACTER(LEN=*)             :: case
REAL(RP), INTENT(IN)         :: sumprec
! Local variables 
REAL(RP)                     :: tmp1, k
INTEGER                      :: n_mod_y, n_mod_z
REAL(RP)                     :: t_beg,t_end
!
CALL CPU_TIME(t_beg)
!
wave%freq2   = 2.0_rp * wave%freq
wave%sumprec = sumprec 
k            = wave_number_adim_r(wave%freq2, wave%prec)
!
IF ( ABS(wave%basin%L_y) > tiny ) THEN
   tmp1 = PI / wave%basin%L_y
   wave%N(2) = FLOOR(k / tmp1)
ELSE
   wave%N(2) = 0
   WRITE(*,*) 'should be a 2D case (inialise_wave2)'
END IF
!
write(*,*) wave%basin%type
wave%TF_f = TF_adim(wave, 2)
!
! Memory allocation
IF ( wave%dimension == '2D' ) THEN
   WRITE(*,'(A)') '2D case'
   IF ( case == 'testoo' ) THEN
      ! made for test on al_mn(0,0) only
      n_mod_z = 0
      n_mod_y = 0
   ELSE
      n_mod_z = 40
      n_mod_y = 0
   END IF
ELSE IF ( wave%dimension == '3D' ) THEN
   WRITE(*,'(A)') '3D case'
   IF ( case == 'free' ) THEN
      n_mod_z = 0
      n_mod_y = wave%N(2)
   ELSE IF ( case == 'basin' ) THEN
      n_mod_z = 8 ! 20
      n_mod_y = 2*wave%N(2)
   ELSE IF ( case == 'wwwfb' ) THEN
      n_mod_z = 5 ! 20
      n_mod_y = wave%N(2)
   ELSE
      WRITE(*,'(A)') 'Unknown case for size allocation'
   END IF
ELSE
   WRITE(*,'(A)') 'Unknown dimension for size allocation'
END IF
!
wave%n_mod_z(2) = n_mod_z
wave%n_mod_y(2) = n_mod_y
!
CALL CPU_TIME(t_end)
!
WRITE(*,'(A,ES12.4,A)') 'Initialized in ',t_end-t_beg,' s.'
!
END SUBROUTINE initialize_wave2
!
!
!
FUNCTION alpha_m(wave,m)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m
COMPLEX(CP)   :: alpha_m
REAL(RP)      :: k
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: alpha
INTEGER       :: s
!
IF ( ASSOCIATED(wave%alpha_m) ) THEN
   s = SIZE(wave%alpha_m)-1
   IF ( s < m) THEN
      ALLOCATE(alpha(0:s))
      alpha = wave%alpha_m
      DEALLOCATE(wave%alpha_m)
      NULLIFY(wave%alpha_m)
      ALLOCATE(wave%alpha_m(0:m))
      wave%alpha_m(0:s)     = alpha
      wave%alpha_m(s+1:m-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%alpha_m(m)       = CMPLX(alpha_adim_r(wave%freq, m, wave%prec), 0.0_rp, KIND=CP)
    ELSE IF ( ABS(wave%alpha_m(m)) < tiny ) THEN
      IF ( m == 0 ) THEN
         k             = wave_number_adim_r(wave%freq, wave%prec)
         wave%alpha_m(0) = i * CMPLX(k, 0.0_rp, KIND=CP)
      ELSE
         wave%alpha_m(m)   = CMPLX(alpha_adim_r(wave%freq, m, wave%prec), 0.0_rp, KIND=CP)
      END IF
   END IF
ELSE
   ALLOCATE(wave%alpha_m(0:m))
   wave%alpha_m(0:m-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   IF ( m == 0 ) THEN
      k             = wave_number_adim_r(wave%freq, wave%prec)
      wave%alpha_m(0) = i * CMPLX(k, 0.0_rp, KIND=CP)
   ELSE
      wave%alpha_m(m) = CMPLX(alpha_adim_r(wave%freq, m, wave%prec), 0.0_rp, KIND=CP)
   END IF  
END IF
!
alpha_m = wave%alpha_m(m)
!
END FUNCTION alpha_m
!
!
!
FUNCTION mu_n(wave,n)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: n
REAL(RP)      :: mu_n
REAL(RP), ALLOCATABLE, DIMENSION(:) :: mu
INTEGER       :: s
!
IF ( wave%dimension == '2D' ) THEN
   IF ( n > 0 ) WRITE(*,*) 'n>0 while 2D case'
   IF ( .NOT.(ASSOCIATED(wave%mu_n)) ) THEN
      ALLOCATE(wave%mu_n(0:0))
      wave%mu_n(0) = 0.0_rp
   ELSE
      wave%mu_n(0) = 0.0_rp
   END IF
ELSE IF ( wave%dimension == '3D' ) THEN
   IF ( ASSOCIATED(wave%mu_n) ) THEN
      s = SIZE(wave%mu_n) - 1
      IF ( s < n) THEN
         ALLOCATE(mu(0:s))
         mu = wave%mu_n
         DEALLOCATE(wave%mu_n)
         NULLIFY(wave%mu_n)
         ALLOCATE(wave%mu_n(0:n))
         wave%mu_n(0:s)     = mu
         wave%mu_n(s+1:n-1) = 0.0_rp
         wave%mu_n(n)       = PI / wave%basin%L_y * n
      ELSE IF ( ABS(wave%mu_n(n)) < tiny ) THEN
         wave%mu_n(n)   = PI / wave%basin%L_y * n
      END IF
   ELSE
      ALLOCATE(wave%mu_n(0:n))
      wave%mu_n(0:n-1) = 0.0_rp
      wave%mu_n(n)     = PI / wave%basin%L_y * n
   END IF
ELSE
   WRITE(*,'(3A)') 'Unknown dimension ',wave%dimension,' in mu_n'
END IF
!
mu_n = wave%mu_n(n)
!
END FUNCTION mu_n
!
!
!
FUNCTION k_mn(wave,m,n)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m, n
COMPLEX(CP)      :: k_mn
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:) :: k
INTEGER       :: s1,s2,mbou,nbou
!
IF ( ASSOCIATED(wave%k_mn) ) THEN
   s1 = SIZE(wave%k_mn,1)-1
   s2 = SIZE(wave%k_mn,2)-1
   IF ( s1 < m .OR. s2 < n ) THEN
      ALLOCATE(k(0:s1,0:s2))
      k = wave%k_mn
      DEALLOCATE(wave%k_mn)
      NULLIFY(wave%k_mn)
      ALLOCATE(wave%k_mn(0:MAX(m,s1),0:MAX(n,s2)))
      wave%k_mn(0:s1,0:s2) = k
      DEALLOCATE(k)
      IF ( s1 < m .AND. s2 >= n ) THEN
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE IF ( s1 >= m .AND. s2 < n ) THEN
         FORALL(mbou=0:s1,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         FORALL(mbou=0:m,nbou=s2+1:n)  wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!          FORALL(mbou=s1+1:m,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      END IF
      wave%k_mn(m,n)       = SQRT(mu_n(wave,n)**2 + alpha_m(wave,m)**2)
   ELSE IF ( ABS(wave%k_mn(m,n)) < tiny ) THEN
      wave%k_mn(m,n)       = SQRT(mu_n(wave,n)**2 + alpha_m(wave,m)**2)
   END IF
ELSE
   ALLOCATE(wave%k_mn(0:m,0:n))
   wave%k_mn = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%k_mn(m,n) = SQRT(mu_n(wave,n)**2 + alpha_m(wave,m)**2)
END IF
!
k_mn = wave%k_mn(m,n)
!
END FUNCTION k_mn
!
!
!
FUNCTION Inty_n(wave,n)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: n
COMPLEX(CP)   :: Inty_n
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: Int_y
INTEGER       :: s
!
IF ( ASSOCIATED(wave%Inty_n) ) THEN
   s = SIZE(wave%Inty_n)-1
   IF ( s < n) THEN
      ALLOCATE(Int_y(0:s))
      Int_y = wave%Inty_n
      DEALLOCATE(wave%Inty_n)
      NULLIFY(wave%Inty_n)
      ALLOCATE(wave%Inty_n(0:n))
      wave%Inty_n(0:s)     = Int_y
      wave%Inty_n(s+1:n-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%Inty_n(n)       = Inty(wave,n)
   ELSE IF ( ABS(wave%Inty_n(n)) < tiny ) THEN
      wave%Inty_n(n)       = Inty(wave,n)
   END IF
ELSE
   ALLOCATE(wave%Inty_n(0:n))
   wave%Inty_n(0:n-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%Inty_n(n)     = Inty(wave,n)
END IF
!
Inty_n = wave%Inty_n(n)
!
END FUNCTION Inty_n
!
!
!
FUNCTION Inty(wave,n)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: n
COMPLEX(CP)      :: Inty
COMPLEX(CP)      :: moins_un, resu
REAL(RP)         :: tmp1, L_w, tmp2
!
IF ( wave%wavemaker == 'snake' .OR. wave%wavemaker == 'Dalrymple' ) THEN
!
! Snake and Dalrymple development
!
!   WRITE(2,*) 'snake or dalrymple'
   IF ( ABS(wave%angle) < tiny .OR. wave%dimension == '2D' ) THEN
      IF ( n /= 0 ) THEN
         resu = CMPLX(0.0_rp, 0.0_rp, KIND = CP)
      ELSE
         resu = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
      END IF
   ELSE
      tmp1 = AIMAG(alpha_m(wave,0)) * SIN(wave%angle)
      tmp2 = mu_n(wave,n)
      IF ( ABS(tmp2-tmp1) > tiny ) THEN
         IF ( MOD(n,2) == 0 ) THEN
            moins_un = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
         ELSE
            moins_un = CMPLX(-1.0_rp, 0.0_rp, KIND=CP)
         END IF
         resu = i * tmp1 / (tmp1**2 - tmp2**2) * (EXP(-i*tmp1*wave%basin%L_y)*&
         moins_un - CMPLX(1.0_rp, 0.0_rp, KIND=CP))
      ELSE
         resu = CMPLX(wave%basin%L_y / 2.0_rp, 0.0_rp, KIND=CP)
      END IF
!
      resu = resu * CMPLX(1.0_rp / wave%basin%L_y, 0.0_rp, KIND=CP)
      IF ( n /= 0 ) THEN
         resu = resu * CMPLX(2.0_rp , 0.0_rp, KIND=CP)
      END IF
   END IF
ELSE IF ( wave%wavemaker == 'B600' ) THEN
!
! B600 development
!
   L_w = wave%basin%L_l - wave%basin%L_r
   IF (ABS(wave%angle) < tiny) THEN
      IF ( n /= 0 ) THEN
         tmp2 = mu_n(wave,n)
         resu = CMPLX(2.0_rp*(SIN(tmp2*wave%basin%L_l)-SIN(tmp2*wave%basin%L_r))/&
                (wave%basin%L_y * tmp2), 0.0_rp, KIND=CP)
      ELSE
         resu = CMPLX(L_w / wave%basin%L_y, 0.0_rp, KIND = CP)
      END IF
   ELSE
      tmp1 = AIMAG(alpha_m(wave,0)) * SIN(wave%angle)
      tmp2 = mu_n(wave,n)
      IF ( ABS(tmp2-tmp1) > tiny ) THEN
         resu = ( &
                 EXP(-i * tmp1 * wave%basin%L_l) * &
                 (tmp2 * SIN(tmp2 * wave%basin%L_l) - i * tmp1 * COS(tmp2 * wave%basin%L_l)) &
                  - EXP(- i * tmp1 * wave%basin%L_r) * &
                 (tmp2 * SIN(tmp2 * wave%basin%L_r) - i * tmp1 * COS(tmp2 * wave%basin%L_r)) &
                ) / (tmp2**2 - tmp1**2)
      ELSE
         resu = ((EXP(2.0_rp*i*tmp1*wave%basin%L_l)-EXP(2.0_rp*i*tmp1*wave%basin%L_r)) &
                  /(2.0_rp*i*tmp1) + L_w) / 2.0_rp
      END IF
      !
      resu = resu * CMPLX(1.0_rp / wave%basin%L_y, 0.0_rp, KIND=CP)
      IF ( n /= 0 ) THEN
         resu = resu * CMPLX(2.0_rp, 0.0_rp, KIND=CP)
      END IF
   END IF
END IF
!
Inty = resu
!
END FUNCTION Inty
!
!
!
FUNCTION TF_m(wave,m,part)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m, part
COMPLEX(CP)   :: TF_m
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:) :: TF
INTEGER       :: s
!
IF ( ASSOCIATED(wave%TF_m) ) THEN
   s = SIZE(wave%TF_m,1)-1
   IF ( s < m) THEN
      ALLOCATE(TF(0:s,2))
      TF = wave%TF_m
      DEALLOCATE(wave%TF_m)
      NULLIFY(wave%TF_m)
      ALLOCATE(wave%TF_m(0:m,2))
      wave%TF_m(0:s,:)     = TF
      wave%TF_m(s+1:m-1,:) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%TF_m(m,1)       = TE_adim(wave, m, 1)
      wave%TF_m(m,2)       = TE_adim(wave, m, 2)
   ELSE IF ( ABS(wave%TF_m(m,1)) < tiny ) THEN
      IF ( m == 0 ) THEN
         wave%TF_m(0,1) = TF_adim(wave, 1)
         wave%TF_m(0,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         wave%TF_m(m,1) = TE_adim(wave, m, 1)
         wave%TF_m(m,2) = TE_adim(wave, m, 2)
      END IF  
   END IF
ELSE
   ALLOCATE(wave%TF_m(0:m,2))
   wave%TF_m(0:m-1,:) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   IF ( m == 0 ) THEN
      wave%TF_m(0,1) = TF_adim(wave, 1)
      wave%TF_m(0,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   ELSE
      wave%TF_m(m,1) = TE_adim(wave, m, 1)
      wave%TF_m(m,2) = TE_adim(wave, m, 2)
   END IF  
END IF
!
IF ( part == 0 ) THEN 
   TF_m = wave%TF_m(m,1) + wave%TF_m(m,2)
ELSE
   TF_m = wave%TF_m(m,part)
END IF
!
END FUNCTION TF_m
!
!
!
FUNCTION TF_mn(wave,m,n,part)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m,n,part
COMPLEX(CP)   :: TF_mn
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:,:) :: TF
INTEGER       :: s1, s2,mbou,nbou
!
IF ( ASSOCIATED(wave%TF_mn) ) THEN
   s1 = SIZE(wave%TF_mn,1)-1
   s2 = SIZE(wave%TF_mn,2)-1
   IF ( s1 < m .OR. s2 < n ) THEN
      ALLOCATE(TF(0:s1,0:s2,2))
      TF = wave%TF_mn
      DEALLOCATE(wave%TF_mn)
      NULLIFY(wave%TF_mn)
      ALLOCATE(wave%TF_mn(0:MAX(m,s1),0:MAX(n,s2),2))
      wave%TF_mn(0:s1,0:s2,:) = TF
      IF ( s1 < m .AND. s2 >= n ) THEN
         FORALL(mbou=s1+1:m,nbou=0:s2) 
            wave%TF_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%TF_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      ELSE IF ( s1 >= m .AND. s2 < n ) THEN
         FORALL(mbou=0:s1,nbou=s2+1:n) 
            wave%TF_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%TF_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      ELSE
         FORALL(mbou=s1+1:m,nbou=0:s2) 
            wave%TF_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%TF_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
         FORALL(mbou=0:m,nbou=s2+1:n) 
            wave%TF_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%TF_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      END IF
      IF ( m == 0 ) THEN
         wave%TF_mn(m,n,1) = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
         wave%TF_mn(m,n,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         wave%TF_mn(m,n,1) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                              TF_m(wave,m,1)
         wave%TF_mn(m,n,2) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                              TF_m(wave,m,2)
      END IF
   ELSE IF ( ABS(wave%TF_mn(m,n,1)) < tiny ) THEN
      IF ( m == 0 ) THEN
         wave%TF_mn(m,n,1) = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
         wave%TF_mn(m,n,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         wave%TF_mn(m,n,1) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                              TF_m(wave,m,1)
         wave%TF_mn(m,n,2) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                              TF_m(wave,m,2)
      END IF
   END IF
ELSE
   ALLOCATE(wave%TF_mn(0:m,0:n,2))
   wave%TF_mn      = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   IF ( m == 0 ) THEN
      wave%TF_mn(m,n,1) = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
      wave%TF_mn(m,n,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   ELSE
      wave%TF_mn(m,n,1) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                            TF_m(wave,m,1)
      wave%TF_mn(m,n,2) = k_mn(wave,0,n) / k_mn(wave,m,n) * alpha_m(wave,m) / alpha_m(wave,0) *&
                            TF_m(wave,m,2)
   END IF
END IF
!
IF ( part == 0 ) THEN 
   TF_mn = wave%TF_mn(m,n,1) + wave%TF_mn(m,n,2)
ELSE
   TF_mn = wave%TF_mn(m,n,part)
END IF
!
END FUNCTION TF_mn
!
!
!
FUNCTION a_on(wave,n)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: n
COMPLEX(CP)   :: a_on
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: a
INTEGER       :: s
CHARACTER(len=9) :: test
LOGICAL          :: test_log
!
test     = wave%wavemaker
test_log = test /= 'snake' .AND. test /= 'Dalrymple' .AND. test /= 'B600' .AND. test /= 'Boudet'
!
IF ( test_log ) STOP 'Unknown wavemaker commad in a_on !!!' 

IF ( ASSOCIATED(wave%a_on) ) THEN
!   tmpc = wave%alpha_m(0) * COS(wave%angle)
   s = SIZE(wave%a_on)-1
   IF ( s < n) THEN
      ALLOCATE(a(0:s))
      a = wave%a_on
      DEALLOCATE(wave%a_on)
      NULLIFY(wave%a_on)
      ALLOCATE(wave%a_on(0:n))
      wave%a_on(0:s)     = a
      wave%a_on(s+1:n-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      IF ( wave%wavemaker == 'snake' .OR. wave%wavemaker == 'B600' ) THEN
         wave%a_on(n) = alpha_m(wave,0) * COS(wave%angle) / k_mn(wave,0,n) * Inty_n(wave,n) 
      ELSE IF ( wave%wavemaker == 'Dalrymple' ) THEN
         IF ( n <= wave%N(1) ) THEN
            wave%a_on(n) = EXP(wave%X_d * (k_mn(wave,0,n) - alpha_m(wave,0) * &
                  COS(wave%angle))) * Inty_n(wave,n)
         ELSE
            wave%a_on(n) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END IF
      ELSE IF ( wave%wavemaker == 'Boudet' ) THEN
            wave%a_on(n) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      END IF
   ELSE IF ( ABS(wave%a_on(n)) < tiny ) THEN
      IF ( wave%wavemaker == 'snake' .OR. wave%wavemaker == 'B600' ) THEN
         wave%a_on(n) = alpha_m(wave,0) * COS(wave%angle) / k_mn(wave,0,n) * Inty_n(wave,n) 
      ELSE IF ( wave%wavemaker == 'Dalrymple' ) THEN
         IF ( n <= wave%N(1) ) THEN
            wave%a_on(n) = EXP(wave%X_d * (k_mn(wave,0,n) - alpha_m(wave,0) * &
                            COS(wave%angle))) * Inty_n(wave,n)
         ELSE
            wave%a_on(n) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END IF
      END IF
   END IF
ELSE
   ALLOCATE(wave%a_on(0:n))
   wave%a_on(0:n-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   IF ( wave%wavemaker == 'snake' .OR. wave%wavemaker == 'B600' ) THEN
       wave%a_on(n) = alpha_m(wave,0) * COS(wave%angle) / k_mn(wave,0,n) * Inty_n(wave,n) 
   ELSE IF ( wave%wavemaker == 'Dalrymple' ) THEN
      IF ( n <= wave%N(1) ) THEN
         wave%a_on(n) = EXP(wave%X_d * (k_mn(wave,0,n) - alpha_m(wave,0) * &
                        COS(wave%angle))) * Inty_n(wave,n)
      ELSE
         wave%a_on(n) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      END IF
   END IF
END IF
!
a_on = wave%a_on(n)
!
END FUNCTION a_on
!
!
!
FUNCTION a_mn(wave,m,n,part)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m,n,part
COMPLEX(CP)   :: a_mn
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:,:) :: a
INTEGER       :: s1, s2,mbou,nbou
!
IF ( ASSOCIATED(wave%a_mn) ) THEN
   s1 = SIZE(wave%a_mn,1)-1
   s2 = SIZE(wave%a_mn,2)-1
   IF ( s1 < m .OR. s2 < n ) THEN
      ALLOCATE(a(0:s1,0:s2,2))
      a = wave%a_mn
      DEALLOCATE(wave%a_mn)
      NULLIFY(wave%a_mn)
      ALLOCATE(wave%a_mn(0:MAX(m,s1),0:MAX(n,s2),2))
      wave%a_mn(0:s1,0:s2,:) = a
      IF ( s1 < m .AND. s2 >= n ) THEN
         FORALL(mbou=s1+1:m,nbou=0:s2)
           wave%a_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
           wave%a_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      ELSE IF ( s1 >= m .AND. s2 < n ) THEN
         FORALL(mbou=0:s1,nbou=s2+1:n)
            wave%a_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%a_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      ELSE
         FORALL(mbou=s1+1:m,nbou=0:s2)
            wave%a_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%a_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
         FORALL(mbou=0:m,nbou=s2+1:n)
            wave%a_mn(mbou,nbou,1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
            wave%a_mn(mbou,nbou,2) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         END FORALL
      END IF
      wave%a_mn(m,n,1) = TF_mn(wave,m,n,1) * a_on(wave,n)
      wave%a_mn(m,n,2) = TF_mn(wave,m,n,2) * a_on(wave,n)
   ELSE IF ( ABS(wave%a_mn(m,n,1)) < tiny ) THEN
      wave%a_mn(m,n,1) = TF_mn(wave,m,n,1) * a_on(wave,n)
      wave%a_mn(m,n,2) = TF_mn(wave,m,n,2) * a_on(wave,n)
   END IF
ELSE
   ALLOCATE(wave%a_mn(0:m,0:n,2))
   wave%a_mn      = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%a_mn(m,n,1) = TF_mn(wave,m,n,1) * a_on(wave,n)
   wave%a_mn(m,n,2) = TF_mn(wave,m,n,2) * a_on(wave,n)
END IF
!
IF ( part == 0 ) THEN 
   a_mn = wave%a_mn(m,n,1) + wave%a_mn(m,n,2)
ELSE
   a_mn = wave%a_mn(m,n,part)
END IF
!
END FUNCTION a_mn
!
!
!
FUNCTION alpha_pm(wave,m,n,p,q,sign)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
COMPLEX(CP)   :: alpha_pm
INTEGER       :: m, n, p, q, sign
!
alpha_pm = SQRT((k_mn(wave,m,n) + k_mn(wave,p,q))**2 - &
                (mu_n(wave,n) + sign * mu_n(wave,q))**2)
!
END FUNCTION alpha_pm
!
!
!
FUNCTION a_4p(wave,m,n,p,q)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m, n, p, q
COMPLEX(CP)      :: a_4p
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:,:,:) :: a
INTEGER       :: s1,s2,s3,s4
!
IF ( ASSOCIATED(wave%a_4p) ) THEN
   s1 = SIZE(wave%a_4p,1)-1
   s2 = SIZE(wave%a_4p,2)-1
   s3 = SIZE(wave%a_4p,3)-1
   s4 = SIZE(wave%a_4p,4)-1
   IF ( s1 < m .OR. s2 < n .OR. s3 < p .OR. s4 < q ) THEN
      ALLOCATE(a(0:s1,0:s2,0:s3,0:s4))
      a = wave%a_4p
      DEALLOCATE(wave%a_4p)
      NULLIFY(wave%a_4p)
      ALLOCATE(wave%a_4p(0:MAX(m,s1),0:MAX(n,s2),0:MAX(p,s3),0:MAX(q,s4)))
      wave%a_4p(:,:,:,:)             = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%a_4p(0:s1,0:s2,0:s3,0:s4) = a
      DEALLOCATE(a)
!	  IF ( s1 < m .AND. s2 >= n ) THEN
!	      FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  ELSE IF ( s1 >= m .AND. s2 < n ) THEN
!	      FORALL(mbou=0:s1,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  ELSE
!	      FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	      FORALL(mbou=0:m,nbou=s2+1:n)  wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!!          FORALL(mbou=s1+1:m,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  END IF
      wave%a_4p(m,n,p,q)       = a_4pm_int(wave,m,n,p,q,+1)
   ELSE IF ( ABS(wave%a_4p(m,n,p,q)) < tiny ) THEN
      wave%a_4p(m,n,p,q)       = a_4pm_int(wave,m,n,p,q,+1)
   END IF
ELSE
   ALLOCATE(wave%a_4p(0:m,0:n,0:p,0:q))
   wave%a_4p          = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%a_4p(m,n,p,q) = a_4pm_int(wave,m,n,p,q,+1)
END IF
!
a_4p = wave%a_4p(m,n,p,q)
!
END FUNCTION a_4p
!
!
!
FUNCTION a_4m(wave,m,n,p,q)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m, n, p, q
COMPLEX(CP)      :: a_4m
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:,:,:) :: a
INTEGER       :: s1,s2,s3,s4
!
IF ( ASSOCIATED(wave%a_4m) ) THEN
   s1 = SIZE(wave%a_4m,1)-1
   s2 = SIZE(wave%a_4m,2)-1
   s3 = SIZE(wave%a_4m,3)-1
   s4 = SIZE(wave%a_4m,4)-1
   IF ( s1 < m .OR. s2 < n .OR. s3 < p .OR. s4 < q ) THEN
      ALLOCATE(a(0:s1,0:s2,0:s3,0:s4))
      a = wave%a_4m
      DEALLOCATE(wave%a_4m)
      NULLIFY(wave%a_4m)
      ALLOCATE(wave%a_4m(0:MAX(m,s1),0:MAX(n,s2),0:MAX(p,s3),0:MAX(q,s4)))
      wave%a_4m(:,:,:,:)             = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%a_4m(0:s1,0:s2,0:s3,0:s4) = a
      DEALLOCATE(a)
!	  IF ( s1 < m .AND. s2 >= n ) THEN
!	      FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  ELSE IF ( s1 >= m .AND. s2 < n ) THEN
!	      FORALL(mbou=0:s1,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  ELSE
!	      FORALL(mbou=s1+1:m,nbou=0:s2) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	      FORALL(mbou=0:m,nbou=s2+1:n)  wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!!          FORALL(mbou=s1+1:m,nbou=s2+1:n) wave%k_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!	  END IF
      wave%a_4m(m,n,p,q)       = a_4pm_int(wave,m,n,p,q,-1)
   ELSE IF ( ABS(wave%a_4m(m,n,p,q)) < tiny ) THEN
      wave%a_4m(m,n,p,q)       = a_4pm_int(wave,m,n,p,q,-1)
   END IF
ELSE
   ALLOCATE(wave%a_4m(0:m,0:n,0:p,0:q))
   wave%a_4m          = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%a_4m(m,n,p,q) = a_4pm_int(wave,m,n,p,q,-1)
END IF
!
a_4m = wave%a_4m(m,n,p,q)
!
END FUNCTION a_4m
!
!
!
FUNCTION a_4pm_int(wave,m,n,p,q,pm)
!
IMPLICIT NONE
!
TYPE(wave_12)              :: wave
INTEGER                    :: m, n, p, q, pm
COMPLEX(CP)                :: a_4pm_int
COMPLEX(CP)                :: resu
COMPLEX(CP), DIMENSION(11) :: tmp
REAL(RP), SAVE             :: nu,w,w2,w4,w46,w24, w43, w28
!
IF ( ABS(nu-wave%freq) > tiny ) THEN
   nu  = wave%freq
   w   = TWOPI * nu
   w2  = w**2
   w4  = w2**2
   w46 = 6.0_rp *  w4
   w24 = -4.0_rp * w2
   w43 = 3.0_rp *  w4
   w28 = 8.0_rp * w2
END IF
!
tmp(1) = w46
tmp(2) = w24
tmp(3) = (mu_n(wave,n) + pm * mu_n(wave,q))**2
tmp(4) = CMPLX(2.0_rp,0.0_rp,KIND=CP) * mu_n(wave,n) * mu_n(wave,q)
tmp(5) = k_mn(wave,m,n) + k_mn(wave,p,q)
tmp(5) = tmp(5) * tmp(5)
tmp(6) = tmp(5) - tmp(3)
tmp(7) = SQRT(tmp(6))
tmp(8) = CMPLX(2.0_rp,0.0_rp,KIND=CP) * k_mn(wave,m,n) * k_mn(wave,p,q)
tmp(9) = a_mn(wave,m,n,0) * a_mn(wave,p,q,0)
tmp(10) = EXP(i*tmp(7))
tmp(11) = 1.0_rp/tmp(10)
!
resu = tmp(9) * (tmp(1) + tmp(8) + tmp(6) - pm * tmp(4)) / (tmp(2) + &
      i * tmp(7) * (tmp(10) - tmp(11)) &
         / (tmp(10) + tmp(11)))
!
resu = resu / CMPLX(4.0_rp, 0.0_rp, KIND=CP)
!
tmp(1) = w43
tmp(2) = w28
tmp(3) = CMPLX(mu_n(wave,n) * mu_n(wave,q), 0.0_rp, KIND=CP)
tmp(4) = tmp(1) - pm * tmp(3)
tmp(5) = a_mn(wave,m,n,0) * a_mn(wave,p,q,0)
tmp(6) = k_mn(wave,m,n) * k_mn(wave,p,q)
resu = resu + tmp(5) * (tmp(4) + tmp(6)) / tmp(2)
!
a_4pm_int = resu
!
END FUNCTION a_4pm_int
!
!
!
FUNCTION beta_m(wave,m)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m
COMPLEX(CP)   :: beta_m
REAL(RP)      :: k
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: beta
INTEGER       :: s
!
IF ( ASSOCIATED(wave%beta_m) ) THEN
   s = SIZE(wave%beta_m)-1
   IF ( s < m) THEN
      ALLOCATE(beta(0:s))
      beta = wave%beta_m
      DEALLOCATE(wave%beta_m)
      NULLIFY(wave%beta_m)
      ALLOCATE(wave%beta_m(0:m))
      wave%beta_m(0:s)     = beta
      wave%beta_m(s+1:m-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      wave%beta_m(m)       = CMPLX(alpha_adim_r(wave%freq2, m, wave%prec), 0.0_rp, KIND=CP)
   ELSE IF ( ABS(wave%beta_m(m)) < tiny ) THEN
      IF ( m == 0 ) THEN
         k            = wave_number_adim_r(wave%freq2, wave%prec)
         wave%beta_m(0) = i * CMPLX(k, 0.0_rp, KIND=CP)
      ELSE
         wave%beta_m(m)   = CMPLX(alpha_adim_r(wave%freq2, m, wave%prec), 0.0_rp, KIND=CP)
      END IF
!   ELSE
!      WRITE(*,*) 'beta_m passe au travers'
   END IF
ELSE
   ALLOCATE(wave%beta_m(0:m))
   wave%beta_m(0:m-1) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   IF ( m == 0 ) THEN
      k             = wave_number_adim_r(wave%freq2, wave%prec)
      wave%beta_m(0) = i * CMPLX(k, 0.0_rp, KIND=CP)
   ELSE
      wave%beta_m(m) = CMPLX(alpha_adim_r(wave%freq2, m, wave%prec), 0.0_rp, KIND=CP)
   END IF  
END IF
!
beta_m = wave%beta_m(m)
!
END FUNCTION beta_m
!
!
!
FUNCTION gamma_mn(wave,m,n)
!
IMPLICIT NONE
!
TYPE(wave_12) :: wave
INTEGER       :: m, n
COMPLEX(CP)      :: gamma_mn
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:) :: gamma
INTEGER       :: s1,s2,mbou,nbou
!
IF ( ASSOCIATED(wave%gamma_mn) ) THEN
   s1 = SIZE(wave%gamma_mn,1)-1
   s2 = SIZE(wave%gamma_mn,2)-1
   IF ( s1 < m .OR. s2 < n ) THEN
      ALLOCATE(gamma(0:s1,0:s2))
      gamma = wave%gamma_mn
      DEALLOCATE(wave%gamma_mn)
      NULLIFY(wave%gamma_mn)
      ALLOCATE(wave%gamma_mn(0:MAX(m,s1),0:MAX(n,s2)))
      wave%gamma_mn(0:s1,0:s2) = gamma
      IF ( s1 < m .AND. s2 >= n ) THEN
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%gamma_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE IF ( s1 >= m .AND. s2 < n ) THEN
         FORALL(mbou=0:s1,nbou=s2+1:n) wave%gamma_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%gamma_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         FORALL(mbou=0:m,nbou=s2+1:n)  wave%gamma_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      END IF
      wave%gamma_mn(m,n)       = SQRT(mu_n(wave,n)**2 + beta_m(wave,m)**2)
   ELSE IF ( ABS(wave%gamma_mn(m,n)) < tiny ) THEN
      wave%gamma_mn(m,n)       = SQRT(mu_n(wave,n)**2 + beta_m(wave,m)**2)
   END IF
ELSE
   ALLOCATE(wave%gamma_mn(0:m,0:n))
   wave%gamma_mn      = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%gamma_mn(m,n) = SQRT(mu_n(wave,n)**2 + beta_m(wave,m)**2)
END IF
!
gamma_mn = wave%gamma_mn(m,n)
!
END FUNCTION gamma_mn
!
!
!
FUNCTION al_mn(wave, m, n, algo1, algo2, algoq)
!
IMPLICIT NONE
!
! Input variables
TYPE(wave_12)    :: wave
INTEGER          :: m,n
CHARACTER(LEN=*) :: algo1,algo2,algoq
! Output variable
COMPLEX(CP)      :: al_mn
! Local variables
COMPLEX(CP), ALLOCATABLE, DIMENSION(:,:) :: a
INTEGER                                  :: s1, s2,mbou,nbou
!
IF ( ASSOCIATED(wave%al_mn) ) THEN
   s1 = SIZE(wave%al_mn,1)-1
   s2 = SIZE(wave%al_mn,2)-1
   IF ( s1 < m .OR. s2 < n ) THEN
      ALLOCATE(a(0:s1,0:s2))
      a = wave%al_mn
      DEALLOCATE(wave%al_mn)
      NULLIFY(wave%al_mn)
      ALLOCATE(wave%al_mn(0:MAX(m,s1),0:MAX(n,s2)))
      wave%al_mn(0:s1,0:s2) = a
      IF ( s1 < m .AND. s2 >= n ) THEN
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%al_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE IF ( s1 >= m .AND. s2 < n ) THEN
         FORALL(mbou=0:s1,nbou=s2+1:n) wave%al_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      ELSE
         FORALL(mbou=s1+1:m,nbou=0:s2) wave%al_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
         FORALL(mbou=0:m,nbou=s2+1:n)  wave%al_mn(mbou,nbou) = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
      END IF
      wave%al_mn(m,n) = al_mn_int(wave, m, n, algo1, algo2, algoq)
   ELSE IF ( ABS(wave%al_mn(m,n)) < tiny ) THEN
      wave%al_mn(m,n) = al_mn_int(wave, m, n, algo1, algo2, algoq)
   END IF
ELSE
   ALLOCATE(wave%al_mn(0:m,0:n))
   wave%al_mn = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
   wave%al_mn(m,n) = al_mn_int(wave, m, n, algo1, algo2, algoq)
END IF
!
al_mn = wave%al_mn(m,n)
!
END FUNCTION al_mn
!
!
!
FUNCTION al_mn_int(wave, m, n, algo1, algo2, algoq)
!
IMPLICIT NONE
!
! Input variables
TYPE(wave_12)    :: wave
INTEGER          :: m,n
CHARACTER(LEN=*) :: algo1,algo2,algoq
! Output variable
COMPLEX(CP)      :: al_mn_int
!
COMPLEX(CP), DIMENSION(4) :: tmp
COMPLEX(CP)               :: resu
!
tmp(1) = beta_m(wave,m)
tmp(2) = EXP( i * tmp(1) )
tmp(3) = tmp(2) * tmp(2)
tmp(4) = tmp(2) + 1.0_rp/tmp(2)
tmp(4) = tmp(4) * tmp(4)
tmp(4) = tmp(4) / &
          (2.0_rp * tmp(1) + (tmp(3) - 1.0_rp/tmp(3)) * (-0.5_rp*i)) &
          * tmp(1) / gamma_mn(wave,m,n)
IF (n==0) THEN
   resu   = tmp(4) * ( sum_qmp(wave, m, n, 1, algo1, algo2, algoq) + &
                    0.5_rp * sum_qmp(wave, m, n,-1, algo1, algo2, algoq) ) * 0.5_rp
ELSE
   resu   = tmp(4) * ( sum_qmp(wave, m, n, 1, algo1, algo2, algoq) + &
                    sum_qmp(wave, m, n,-1, algo1, algo2, algoq) ) * 0.5_rp
END IF
!
al_mn_int = resu
!
END FUNCTION al_mn_int
!
!
!
FUNCTION sum_qmp(wave, m, n, ind, algo1, algo2, algoq)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: m, n, ind
CHARACTER(LEN=*) :: algo1, algo2, algoq
COMPLEX(CP)      :: sum_qmp
!
COMPLEX(CP)      :: resu
INTEGER          :: nmax, qbou, n_tmp
!
resu = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!
IF ( ind == 1) THEN
   nmax = n/2 ! integer division
   DO qbou = 0, nmax
      n_tmp = n - qbou
      IF (ABS(a_on(wave, n_tmp)) > tiny .AND. ABS(a_on(wave, qbou)) > tiny) THEN 
      !IF (a_on(wave, n_tmp) /= 0.0_cp .AND. a_on(wave, qbou) /= 0.0_cp) THEN
         resu = resu + a_on(wave, n_tmp) * a_on(wave, qbou) * &
                     sum_m(wave, m, n, qbou, ind, algo1, algo2)
      END IF
   END DO
   IF ( MOD(n,2) == 0 ) THEN 
      n_tmp = n - nmax
      resu = resu - a_on(wave,n_tmp) * a_on(wave,nmax) * &
                       sum_m(wave, m, n, nmax, ind, algo1, algo2) * 0.5_rp
   END IF
ELSE IF ( ind == -1) THEN
   resu = sum_q(wave, m, n, ind, algo1, algo2, algoq)
END IF
!
sum_qmp = resu
! WRITE(*,*) resu ! pas OK
!WRITE(2,'(A8,2(I3,1X),16X,I3,1X,8X,2(ES10.3,1X))') 'sum_qmp ',m,n,ind, resu
!
END FUNCTION sum_qmp
!
!
!
FUNCTION sum_q(wave, m, n, ind, algo1, algo2, algoq)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: m, n, ind
CHARACTER(LEN=*) :: algo1, algo2, algoq
COMPLEX(CP)      :: sum_q
!
COMPLEX(CP)      :: resu
!
!
IF ( wave%dimension  == '3D' ) THEN
   IF ( algoq == 'salzer' ) THEN
      resu = algo_salzer_q(wave, m, n, ind, algo1, algo2)
   ELSE IF ( algoq == 'direct' ) THEN
      resu = algo_direct_q(wave, m, n, ind, algo1, algo2)
   END IF
ELSE IF ( wave%dimension  == '2D' ) THEN
   resu = a_on(wave,n) * a_on(wave,0) * sum_m(wave, m, n, 0, ind, algo1, algo2) * 0.5_rp
ELSE
   WRITE(*,*) 'Unknown dimension in sum_q'
END IF
!
sum_q = resu
!WRITE(2,'(A8,2(I3,1X),16X,(I3,1X),8X,2(ES10.3,1X))') 'sum_q   ',m,n,ind, resu
!
END FUNCTION sum_q
!
!
!
FUNCTION sum_m(wave, m, n, q, ind, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: m, n, q, ind
CHARACTER(LEN=*) :: algo1, algo2
COMPLEX(CP)      :: sum_m
!
COMPLEX(CP)      :: resu
!
resu = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!
IF ( algo1 == 'salzer' ) THEN
   resu = algo_salzer_m(wave, m, n, q, ind, 1, algo1, algo2)
ELSE IF ( algo1 == 'direct' ) THEN
   resu = algo_direct_m12(wave, m, n, q, ind, algo1, algo2)
END IF
!
IF ( algo2 == 'salzer' ) THEN
   resu = resu + algo_salzer_m(wave, m, n, q, ind, 2, algo1, algo2)
ELSE IF ( algo2 == 'direct' ) THEN
!   resu = resu + algo_direct_m(wave, m, n, q, ind, 2, algo1, algo2)
END IF
!
sum_m = resu
!WRITE(2,'(A8,2(I3,1X),12X,2(I3,1X),8X,2(ES10.3,1X))') 'sum_m   ',m,n,q,ind, resu
!
END FUNCTION sum_m
!
!
!
FUNCTION sum_p(wave, m, n, mm, q, ind, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: m, n, mm, q, ind
CHARACTER(LEN=*) :: algo1, algo2
COMPLEX(CP)      :: sum_p
!
COMPLEX(CP)      :: resu
!
resu = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
!
IF ( algo1 == 'salzer' ) THEN
   resu = algo_salzer_p(wave, m, n, mm, q, ind, 1)
ELSE IF ( algo1 == 'direct' ) THEN
!   resu = algo_direct_p(wave, m, n, mm, q, ind, 1)
   resu = algo_direct_p12(wave, m, n, mm, q, ind)
END IF
!
IF ( algo2 == 'salzer' ) THEN
   resu = resu + algo_salzer_p(wave, m, n, mm, q, ind, 2)
ELSE IF ( algo2 == 'direct' ) THEN
!   resu = resu + algo_direct_p(wave, m, n, mm, q, ind, 2)
END IF
!
sum_p = resu
!WRITE(2,'(A8,3(I3,1X),8X,2(I3,1X),8X,2(ES10.3,1X))') 'sum_p   ',m,n,mm,q,ind, resu
!
END FUNCTION sum_p
!
!
!
FUNCTION algo_salzer_q(wave, m, n, ind, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
COMPLEX(CP)      :: algo_salzer_q
INTEGER          :: m,n, ind
CHARACTER(LEN=*) :: algo1, algo2
!
COMPLEX(CP)                            :: error
INTEGER                                :: q, k, mbou, n_tmp
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: t_nk, t_nk_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
k = 0
! Memory allocation
ALLOCATE(t_nk(0:0))
n_tmp = n - ind * 0
t_nk(0) = a_on(wave,n_tmp) * a_on(wave,0) * sum_m(wave, m, n, 0, ind, algo1, algo2)
!
DO WHILE ( ABS(error) > wave%sumprec )
   !
   k = k + 1
   !
   ! Memory allocation
   IF (ALLOCATED(t_nk_old))  DEALLOCATE(t_nk_old)
   ALLOCATE(t_nk_old(0:k-1))
   t_nk_old = t_nk
   DEALLOCATE(t_nk)
   ALLOCATE(t_nk(0:k))
   !
   ! Initialisation
   q       = k
   n_tmp   = n - ind * q
   t_nk(0) = t_nk_old(0) + a_on(wave,n_tmp) * a_on(wave,q) * sum_m(wave, m, n, q, ind, algo1, algo2)
   !
   ! Recurrence
   DO mbou = 0, k-1
      q            = k - mbou - 1
      t_nk(mbou+1) = (CMPLX(q + mbou + 2, 0.0_rp, KIND=CP) * t_nk(mbou) - &
                      CMPLX(q + 1       , 0.0_rp, KIND=CP) * t_nk_old(mbou)) / &
                      CMPLX(mbou + 1    , 0.0_rp, KIND=CP)
   END DO
   !
!   error = t_nk(k-1) - t_nk_old(k-1)
   error = (t_nk(k-1) - t_nk_old(k-1)) / t_nk_old(k-1)
!   error = t_nk(0) - t_nk_old(0)
   !
END DO
!
!algo_salzer_q = t_nk(0)
algo_salzer_q = t_nk(k)
!WRITE(2,'(A8,2(I3,1X),16X,2(I3,1X),4X,2(ES10.3,1X))') 'salzer_q',m,n,ind,k,algo_salzer_q
!
END FUNCTION algo_salzer_q
!
!
!
FUNCTION algo_salzer_m(wave,m,n,q, ind,part,algo1,algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
COMPLEX(CP)      :: algo_salzer_m
INTEGER          :: m,n,q, ind
INTEGER          :: part
CHARACTER(LEN=*) :: algo1, algo2
!
COMPLEX(CP)                            :: error
INTEGER                                :: mm, k, mbou, n_tmp
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: t_nk, t_nk_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
k = 0
! Memory allocation
ALLOCATE(t_nk(0:0))
n_tmp = n - ind * q
t_nk(0) = TF_mn(wave,0,n_tmp,part) * sum_p(wave,m,n,0,q,ind,algo1,algo2)
!
DO WHILE ( ABS(error) > wave%sumprec )
   !
   k = k + 1
   !
   ! Memory allocation
   IF (ALLOCATED(t_nk_old))  DEALLOCATE(t_nk_old)
   ALLOCATE(t_nk_old(0:k-1))
   t_nk_old = t_nk
   DEALLOCATE(t_nk)
   ALLOCATE(t_nk(0:k))
   !
   ! Initialisation
   mm      = k
   n_tmp = n - ind * q
   t_nk(0) = t_nk_old(0) + TF_mn(wave,mm,n_tmp,part) * sum_p(wave,m,n,mm,q,ind,algo1,algo2)
   !
   ! Recurrence
   DO mbou = 0, k-1
      mm           = k - mbou - 1
      t_nk(mbou+1) = (CMPLX(mm + mbou + 2, 0.0_rp, KIND=CP) * t_nk(mbou) - &
                      CMPLX(mm + 1       , 0.0_rp, KIND=CP) * t_nk_old(mbou)) / &
                      CMPLX(mbou + 1    , 0.0_rp, KIND=CP)
   END DO
   !
!   error = t_nk(k-1) - t_nk_old(k-1)
   error = (t_nk(k-1) - t_nk_old(k-1)) / t_nk_old(k-1)
!   error = t_nk(0) - t_nk_old(0)
   !
END DO
!
!algo_salzer_m = t_nk(0)
algo_salzer_m = t_nk(k)
!WRITE(2,*) t_nk 
!WRITE(2,'(A8,2(I3,1X),12X,3(I3,1X),4X,2(ES10.3,1X))') 'salzer_m',m,n,q,ind,k,algo_salzer_m
!
END FUNCTION algo_salzer_m
!
!
!
FUNCTION algo_salzer_p(wave,m,n,mm,q,ind,part)
!
IMPLICIT NONE
!
TYPE(wave_12)              :: wave
COMPLEX(CP)                :: algo_salzer_p
INTEGER                    :: m,n,q,mm,ind
INTEGER        :: part
!
COMPLEX(CP)                            :: error
INTEGER                                :: p, k, mbou
COMPLEX(CP), ALLOCATABLE, DIMENSION(:) :: t_nk, t_nk_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
k = 0
! Memory allocation
ALLOCATE(t_nk(0:0))
t_nk(0) = A_mn_mmpq_2(wave,m,n,mm,0,q,ind,part)
!
DO WHILE ( ABS(error) > wave%sumprec )
   !
   k = k + 1
   !
   ! Memory allocation
   IF (ALLOCATED(t_nk_old))  DEALLOCATE(t_nk_old)
   ALLOCATE(t_nk_old(0:k-1))
   t_nk_old = t_nk
   DEALLOCATE(t_nk)
   ALLOCATE(t_nk(0:k))
   !
   ! Initialisation
   p       = k
   t_nk(0) = t_nk_old(0) + A_mn_mmpq_2(wave,m,n,mm,p,q,ind,part)
   !
   ! Recurrence
   DO mbou = 0, k-1
      p            = k - mbou - 1
      t_nk(mbou+1) = (CMPLX(p + mbou + 2, 0.0_rp, KIND=CP) * t_nk(mbou) - &
                      CMPLX(p + 1       , 0.0_rp, KIND=CP) * t_nk_old(mbou)) / &
                      CMPLX(mbou + 1    , 0.0_rp, KIND=CP)
   END DO
   !
!   error = t_nk(k-1) - t_nk_old(k-1)
   error = (t_nk(k-1) - t_nk_old(k-1)) / t_nk_old(k-1)
!   error = t_nk(0) - t_nk_old(0)
   !
END DO
!
!algo_salzer_p = t_nk(0)
algo_salzer_p = t_nk(k)
!WRITE(2,*) t_nk 
!WRITE(2,'(A8,3(I3,1X),8X,3(I3,1X),4X,2(ES10.3,1X))') 'salzer_p',m,n,mm,q,ind,k,algo_salzer_p
!
END FUNCTION algo_salzer_p
!
!
!
FUNCTION algo_direct_q(wave, m, n, ind, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
COMPLEX(CP)      :: algo_direct_q
INTEGER          :: m,n, ind
CHARACTER(LEN=*) :: algo1, algo2
!
COMPLEX(CP)      :: error
INTEGER          :: q, n_tmp
COMPLEX(CP)      :: S_n, S_n_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
q = 0
n_tmp = n - ind * 0
S_n = a_on(wave,n_tmp) * a_on(wave,0) * sum_m(wave, m, n, 0, ind, algo1, algo2)
!
DO WHILE ( ABS(error) > wave%sumprec .AND. q <= summax)
   !
   q = q + 1
   n_tmp = n - ind * q
   !
   S_n_old = S_n
   S_n = S_n_old + a_on(wave,n_tmp) * a_on(wave,q) * sum_m(wave, m, n, q, ind, algo1, algo2)
   !
   error = (S_n - S_n_old) / S_n_old
   !
END DO
!
algo_direct_q = S_n
!WRITE(2,'(A8,2(I3,1X),16X,2(I3,1X),4X,2(ES10.3,1X))') 'direct_q',m,n,ind,q,algo_direct_q
!
END FUNCTION algo_direct_q
!
!
!
FUNCTION algo_direct_m(wave, m, n, q, ind, part, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)              :: wave
COMPLEX(CP)                :: algo_direct_m
INTEGER                    :: m,n,q, ind
INTEGER        :: part
CHARACTER(LEN=*) :: algo1, algo2
!
COMPLEX(CP)                            :: error
INTEGER                                :: mm, n_tmp
COMPLEX(CP)   :: S_n, S_n_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
mm = 0
n_tmp = n - ind * q
S_n = TF_mn(wave,0,n_tmp,part) * sum_p(wave,m,n,0,q,ind,algo1,algo2)
!
DO WHILE ( ABS(error) > wave%sumprec .AND. mm <= summax)
   !
   mm = mm + 1
   !
   n_tmp = n - ind * q
   S_n_old = S_n
   S_n = S_n_old + TF_mn(wave,mm,n_tmp,part) * sum_p(wave,m,n,mm,q,ind,algo1,algo2)
   !
   error = (S_n - S_n_old) / S_n_old
   !
END DO
!
algo_direct_m = S_n
!WRITE(2,'(A8,2(I3,1X),12X,3(I3,1X),4X,2(ES10.3,1X))') 'direct_m',m,n,q,ind,mm,algo_direct_m
!
END FUNCTION algo_direct_m
!
!
!
FUNCTION algo_direct_m12(wave, m, n, q, ind, algo1, algo2)
!
IMPLICIT NONE
!
TYPE(wave_12)              :: wave
COMPLEX(CP)                :: algo_direct_m12
INTEGER                    :: m,n,q, ind
CHARACTER(LEN=*)           :: algo1, algo2
!
COMPLEX(CP)                :: error, tmp
INTEGER                    :: mm, n_tmp
COMPLEX(CP), DIMENSION(2)  :: S_n, S_n_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
mm     = 0
n_tmp  = n - ind * q
tmp    = sum_p(wave,m,n,0,q,ind,algo1,algo2)
S_n(1) = TF_mn(wave,0,n_tmp,1) * tmp
S_n(2) = TF_mn(wave,0,n_tmp,2) * tmp
!
DO WHILE ( ABS(error) > wave%sumprec .AND. mm <= summax)
   !
   mm = mm + 1
   !
   n_tmp   = n - ind * q
   S_n_old = S_n
   tmp     = sum_p(wave,m,n,mm,q,ind,algo1,algo2)
   S_n(1)  = S_n_old(1) + TF_mn(wave,mm,n_tmp,1) * tmp
   S_n(2)  = S_n_old(2) + TF_mn(wave,mm,n_tmp,2) * tmp
   !
   error   = (S_n(1) - S_n_old(1)) / S_n_old(1)
   !
END DO
!
algo_direct_m12 = S_n(1) + S_n(2)
!WRITE(2,'(A8,2(I3,1X),12X,3(I3,1X),4X,2(ES10.3,1X))') 'dire12_m',m,n,q,ind,mm,algo_direct_m12
!
END FUNCTION algo_direct_m12
!
!
!
FUNCTION algo_direct_p(wave, m, n, mm, q, ind, part)
! summation over 'p' for either part 1 or part 2 (1/p^2 or cos apPI / p^2)
IMPLICIT NONE
!
TYPE(wave_12) :: wave
COMPLEX(CP)   :: algo_direct_p
INTEGER       :: m,n,q,mm,ind
INTEGER       :: part
!
COMPLEX(CP)   :: error
INTEGER       :: p
COMPLEX(CP) :: S_n, S_n_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
p   = 0
S_n = A_mn_mmpq_2(wave,m,n,mm,0,q,ind,part)
!
DO WHILE ( ABS(error) > wave%sumprec  .AND. p <= summax)
   !
   p = p + 1
   !
   S_n_old = S_n
   S_n     = S_n_old + A_mn_mmpq_2(wave,m,n,mm,p,q,ind,part)
   !
   error = (S_n - S_n_old) / S_n_old
   !
END DO
!
algo_direct_p = S_n
!
!WRITE(2,'(A8,3(I3,1X),8X,4(I3,1X),2(ES10.3,1X))') 'direct_p',m,n,mm,q,ind,p,part,algo_direct_p
!
END FUNCTION algo_direct_p
!
!
!
FUNCTION algo_direct_p12(wave, m, n, mm, q, ind)
! summation over 'p' for both parts 1 and 2 (1/p^2 and cos apPI / p^2)
IMPLICIT NONE
!
TYPE(wave_12) :: wave
COMPLEX(CP)   :: algo_direct_p12
INTEGER       :: m,n,q,mm,ind
!
COMPLEX(CP)   :: error
INTEGER       :: p
COMPLEX(CP), DIMENSION(2) :: S_n, S_n_old
!
error = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
!
! Initialisation
p   = 0
S_n(1) = A_mn_mmpq_2(wave,m,n,mm,0,q,ind,1)
S_n(2) = A_mn_mmpq_2(wave,m,n,mm,0,q,ind,2)
!WRITE(*,*) 'S_n',m,n,mm,q,S_n ! pas OK
!
DO WHILE ( ABS(error) > wave%sumprec  .AND. p <= summax)
   !
   p = p + 1
   !
   S_n_old = S_n
   S_n(1)     = S_n_old(1) + A_mn_mmpq_2(wave,m,n,mm,p,q,ind,1)
   S_n(2)     = S_n_old(2) + A_mn_mmpq_2(wave,m,n,mm,p,q,ind,2)
   !
   error = (S_n(1) - S_n_old(1)) / S_n_old(1)
   !
END DO
!
algo_direct_p12 = S_n(1) + S_n(2)
!
!WRITE(2,'(A8,3(I3,1X),8X,3(I3,1X),4X,2(ES10.3,1X))') 'direct_p',m,n,mm,q,ind,p,algo_direct_p12
!
END FUNCTION algo_direct_p12
!
!
!
FUNCTION A_mn_mmpq(wave,m,n,mm,p,q,ind,part_mm,part_p)
!
IMPLICIT NONE
!
TYPE(wave_12)  :: wave
INTEGER        :: m,n,mm,p,q, ind
INTEGER        :: part_mm,part_p
COMPLEX(CP)    :: A_mn_mmpq
COMPLEX(CP)    :: k1,k2,k12, a_pm, b, a1, a2, a12, a1m2, a1p2
REAL(RP)       :: mu12 !, w, w2, w4, w44, w64
REAL(RP), SAVE :: nu, w, w2, w4, w44, w64
INTEGER        :: n_tmp
!
n_tmp = n - ind * q
IF ( ABS(nu-wave%freq) > tiny ) THEN
   nu    = wave%freq
   w     = TWOPI * nu
   w2    = w*w
   w4    = w2*w2
   w44   = 4.0_rp * w4
   w64   = 6.0_rp * w4
END IF
k1    = k_mn(wave,mm,n_tmp)
k2    = k_mn(wave,p,q)
k12   = k1 * k2
a_pm  = alpha_pm(wave,mm,n_tmp,p,q,ind)**2
mu12  = mu_n(wave,n_tmp) * mu_n(wave,q)
b     = beta_m(wave,m)**2
a1    = alpha_m(wave,mm) 
a2    = alpha_m(wave,p) 
a12   = a1 * a2
a1m2  = (a1 - a2)**2
a1p2  = (a1 + a2)**2
!
A_mn_mmpq = (k1 + k2) * a_mn(wave,mm,n_tmp,part_mm) * a_mn(wave,p,q,part_p) * &
   ( &
    (w64 + 2.0_rp * k12 + a_pm - ind * 2.0_rp * mu12) / (a_pm - b) + &
   (a12 + k12 + ind * mu12) / (2.0_rp * a12) * (w44 + a1m2) / (a1p2 - b) + &
   (a12 - k12 - ind * mu12) / (2.0_rp * a12) * (w44 + a1p2) / (a1m2 - b) &
   )
!
!WRITE(2,'(A8,6(I3,X),8X,3(ES10.3,X))') 'A       ',m,n,mm,n_tmp,p,q,A_mn_mmpq,p**2*ABS(A_mn_mmpq)
!
!IF (m==0 ) THEN
!WRITE(3,'( I3,X,3(ES10.3,X))') p,REAL(A_mn_mmpq),AIMAG(A_mn_mmpq),p**2*ABS(A_mn_mmpq)
!END IF
!
END FUNCTION A_mn_mmpq
!
!
!
FUNCTION A_mn_mmpq_2(wave,m,n,mm,p,q,ind,part_p)
!
IMPLICIT NONE
!
TYPE(wave_12)  :: wave
INTEGER        :: m,n,mm,p,q, ind
INTEGER        :: part_p
COMPLEX(CP)    :: A_mn_mmpq_2
COMPLEX(CP)    :: k1,k2,k12, a_pm, b, a1, a2, a12, a1m2, a1p2
REAL(RP)       :: mu12 !, w, w2, w4, w44, w64
REAL(RP), SAVE :: nu, w, w2, w4, w44, w64
INTEGER        :: n_tmp
!
n_tmp = n - ind * q
IF ( ABS(nu-wave%freq) > tiny ) THEN
   nu    = wave%freq
   w     = TWOPI * nu
   w2    = w*w
   w4    = w2*w2
   w44   = 4.0_rp * w4
   w64   = 6.0_rp * w4
END IF
k1    = k_mn(wave,mm,n_tmp)
k2    = k_mn(wave,p,q)
k12   = k1 * k2
a_pm  = alpha_pm(wave,mm,n_tmp,p,q,ind) * alpha_pm(wave,mm,n_tmp,p,q,ind)
mu12  = mu_n(wave,n_tmp) * mu_n(wave,q)
b     = beta_m(wave,m) * beta_m(wave,m)
a1    = alpha_m(wave,mm) 
a2    = alpha_m(wave,p) 
a12   = a1 * a2
a1m2  = (a1 - a2) * (a1 - a2)
a1p2  = (a1 + a2) * (a1 + a2)
!
A_mn_mmpq_2 = (k1 + k2) * TF_mn(wave,p,q,part_p) * &
   ( &
    (w64 + 2.0_rp * k12 + a_pm - ind * 2.0_rp * mu12) / (a_pm - b) + &
   (a12 + k12 + ind * mu12) / (2.0_rp * a12) * (w44 + a1m2) / (a1p2 - b) + &
   (a12 - k12 - ind * mu12) / (2.0_rp * a12) * (w44 + a1p2) / (a1m2 - b) &
   )
!
!IF ( ABS(b) == 0.0_rp ) WRITE(*,*) m 
!WRITE(*,'(A,2I3,ES10.3)') 'TF',p,q,ABS( b ) ! pas OK
!WRITE(*,'(A,2I3,ES10.3)') 'TF',p,q,ABS((a_pm - b)) ! pas OK
!WRITE(*,'(A,2I3,ES10.3)') 'TF',p,q,ABS(a1p2 - b) ! pas OK
!WRITE(*,'(A,2I3,ES10.3)') 'TF',p,q,ABS(a1m2 - b) ! pas OK
!WRITE(*,'(A,5I3,ES10.3)') 'A',m,n,mm,p,q,ABS(A_mn_mmpq_2) ! pas OK
!WRITE(2,'(A8,6(I3,X),8X,3(ES10.3,X))') 'A       ',m,n,mm,n_tmp,p,q,A_mn_mmpq,p**2*ABS(A_mn_mmpq)
!
!IF (m==0 ) THEN
!WRITE(3,'( I3,X,3(ES10.3,X))') p,REAL(A_mn_mmpq),AIMAG(A_mn_mmpq),p**2*ABS(A_mn_mmpq)
!END IF
!
END FUNCTION A_mn_mmpq_2
!
!
!
FUNCTION A_mn_mmpq_3(wave,m,n,mm,p,q,ind,part_p)
!
IMPLICIT NONE
!
TYPE(wave_12)  :: wave
INTEGER        :: m,n,mm,p,q, ind
INTEGER        :: part_p
COMPLEX(CP)    :: A_mn_mmpq_3
COMPLEX(CP)    :: k1,k2,k12, a_pm, b, a1, a2, a12, a1m2, a1p2
REAL(RP)       :: mu12 !, w, w2, w4, w44, w64
REAL(RP), SAVE :: nu, w, w2, w4, w44, w64
INTEGER        :: n_tmp
!
n_tmp = n - ind * q
IF ( ABS(nu-wave%freq) > tiny ) THEN
   nu    = wave%freq
   w     = TWOPI * nu
   w2    = w*w
   w4    = w2*w2
   w44   = 4.0_rp * w4
   w64   = 6.0_rp * w4
END IF
k1    = k_mn(wave,mm,n_tmp)
k2    = k_mn(wave,p,q)
k12   = k1 * k2
a_pm  = alpha_pm(wave,mm,n_tmp,p,q,ind)**2
mu12  = mu_n(wave,n_tmp) * mu_n(wave,q)
b     = beta_m(wave,m)**2
a1    = alpha_m(wave,mm) 
a2    = alpha_m(wave,p) 
a12   = a1 * a2
a1m2  = (a1 - a2)**2
a1p2  = (a1 + a2)**2
!
A_mn_mmpq_3 = (k1 + k2) * TF_mn(wave,p,q,part_p) * &
   ( &
    (w64 + 2.0_rp * k12 + a_pm - ind * 2.0_rp * mu12) / (a_pm - b) + &
   (a12 + k12 + ind * mu12) / (2.0_rp * a12) * (w44 + a1m2) / (a1p2 - b) + &
   (a12 - k12 - ind * mu12) / (2.0_rp * a12) * (w44 + a1p2) / (a1m2 - b) &
   )
!
END FUNCTION A_mn_mmpq_3
!
!
!
FUNCTION TF_adim(wave, mod)
!
! Adimensional Transfer Function, inspired from ECN report potentiel.tex
!   b = TF * a
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: mod
COMPLEX(CP)      :: TF_adim, resu
REAL(RP)         :: k
REAL(RP)         :: d
!
k = get_k(wave, mod)
d = wave%basin%d
!
IF (ABS((TWOPI * mod * wave%freq)**2 - k * TANH(k)) > 1.0E-5_rp) &
WRITE(*,'(A)') 'Wave has not been initialized'
!
!
IF ( wave%basin%type == 'hinged' ) THEN
   resu = CMPLX(0.0_rp, - k * (1.0_rp - d) * (2.0_rp * k + &
                SINH(2.0_rp * k)) / (4.0_rp * SINH(k)), KIND=CP)
   resu = resu * CMPLX(1.0_rp / (k * (1.0_rp - d) * SINH(k) + &
                       COSH(k * d) - COSH(k)), KIND=CP)
ELSE IF ( wave%basin%type == 'piston' ) THEN
   resu = CMPLX(0.0_rp, - (2.0_rp * k + &
                SINH(2.0_rp * k)) / (4.0_rp * SINH(k) * SINH(k)), KIND=CP)
ELSE
   WRITE(*,'(A)') 'Unknown wavemaker type for transfer function'
   resu = CMPLX(1.0_rp, 0.0_rp, KIND=CP)
END IF
!
TF_adim = resu
!
END FUNCTION TF_adim
!
!
!
FUNCTION TE_adim(wave, N, part)
!
! Adimensional Transfer Function, inspired from ECN report potentiel.tex,
!  for evanescent modes
!  a_n = TE_n * a
!
IMPLICIT NONE
!
TYPE(wave_12)    :: wave
INTEGER          :: N, part
COMPLEX(CP)      :: TE_adim, TF, resu
REAL(RP)         :: alpha
REAL(RP)         :: d
!
alpha = get_alpha(wave, N)
TF    = get_TF(wave,0)
d     = wave%basin%d
!
IF ( wave%basin%type == 'hinged' ) THEN
   resu = TF * CMPLX(4.0_rp * SIN(alpha) / (alpha * (1.0_rp - d) &
                        * (2.0_rp * alpha + SIN(2.0_rp * alpha))), 0.0_rp, KIND=CP)
   IF ( part == 1 ) THEN
       resu = resu * CMPLX((alpha * (1.0_rp - d) * SIN(alpha) + &
                                COS(alpha)), 0.0_rp, KIND=CP)
   ELSE IF ( part == 2 ) THEN
      resu = resu * CMPLX(- COS(alpha * d), 0.0_rp, KIND=CP)
   END IF
ELSE IF ( wave%basin%type == 'piston' ) THEN
   resu = TF * CMPLX(4.0_rp * SIN(alpha) * SIN(alpha) / &
                        (2.0_rp * alpha + SIN(2.0_rp * alpha)), 0.0_rp, KIND=CP)
ELSE
   WRITE(*,*) 'Unknown wavemaker type for transfer function of evanescent modes'
END IF
!
TE_adim = resu
!
END FUNCTION TE_adim
!
!
!
FUNCTION get_k(wave, mod)
IMPLICIT NONE
TYPE(wave_12) :: wave
INTEGER       :: mod
REAL(RP)      :: get_k, resu
!
IF (mod == 1) THEN
   resu = AIMAG(alpha_m(wave,0))
ELSE IF (mod == 2) THEN
   resu = AIMAG(beta_m(wave,0))
ELSE
   WRITE(*,'(A)') 'Unknown mode in get_k'
   resu = 0.0_rp
END IF
!
get_k = resu
!
END FUNCTION get_k
!
!
!
FUNCTION get_alpha(wave,N)
IMPLICIT NONE
TYPE(wave_12) :: wave
INTEGER       :: N
REAL(RP)      :: get_alpha
!
get_alpha = REAL(alpha_m(wave,N))
!
END FUNCTION get_alpha
!
!
!
FUNCTION get_TF(wave,part)
IMPLICIT NONE
TYPE(wave_12)  :: wave
COMPLEX(CP)    :: get_TF
INTEGER        :: part
!
get_TF = TF_m(wave,0,part)
!
END FUNCTION get_TF
!
!
!
SUBROUTINE display_freq(wave, mod)
IMPLICIT NONE
TYPE(wave_12), INTENT(IN) :: wave
INTEGER, INTENT(IN)    :: mod
!
IF (mod == 1) THEN
   WRITE(*,'(A,F8.5,A)') 'Frequency   : ',SQRT(g/wave%basin%h) * wave%freq,' Hz'
ELSE IF (mod == 2) THEN
   WRITE(*,'(A,F8.5,A)') 'Frequency   : ',SQRT(g/wave%basin%h) * wave%freq2,' Hz'
ELSE
   WRITE(*,'(A)') 'Unknown mode in display_freq'
END IF
!
END SUBROUTINE display_freq
!
!
!
SUBROUTINE display_ampli(wave)
IMPLICIT NONE
TYPE(wave_12), INTENT(IN) :: wave
!
WRITE(*,'(A,F8.5,A)') 'Amplitude   : ',wave%basin%h * ABS(wave%ampli),' m'
! WRITE(*,'(A,F8.5,A)') 'Phase       : ', phase(wave%ampli),' Rad'
WRITE(*,'(A)') 'Phase not shown (needs function phase wich is only in wave_def.f90)'
!
END SUBROUTINE display_ampli
!
!
!
SUBROUTINE display_N(wave,mod)
IMPLICIT NONE
TYPE(wave_12), INTENT(IN) :: wave
INTEGER, INTENT(IN)    :: mod
!
IF (mod == 1) THEN
   WRITE(*,'(A,I4)') 'Number of propagation modes : ',wave%N(1)
ELSE IF (mod == 2) THEN
   WRITE(*,'(A,I4)') 'Number of propagation modes : ',wave%N(2)
ELSE
   WRITE(*,'(A)') 'Unknown mode in display_N'
END IF
!
END SUBROUTINE display_N
!
!
!
SUBROUTINE display_k(wave, mod)
IMPLICIT NONE
TYPE(wave_12), INTENT(IN) :: wave
INTEGER, INTENT(IN)       :: mod
REAL(RP)                  :: k
!
IF (mod /= 2 .AND. mod /= 1) WRITE(*,'(A)') 'Unknown mode in display_k'
!
k = get_k(wave, mod)
!
WRITE(*,'(A,F12.5,1X,A)') 'Wave number : ', k / wave%basin%h,'m-1'
WRITE(*,'(A,F8.5,A)')    'Wavelength  : ', wave%basin%h * TWOPI / k,' m'
!
END SUBROUTINE display_k
!
!
!
SUBROUTINE select_wavemaker(wave,command,X_d)!,contour,n_pts)
!
IMPLICIT NONE
!
! Input variables
TYPE(wave_12)                     :: wave
CHARACTER(LEN=*)                  :: command
REAL(RP), OPTIONAL                :: X_d
!REAL(RP), DIMENSION(:,:),OPTIONAL :: contour
!INTEGER, DIMENSION(:),OPTIONAL    :: n_pts
!
!WRITE(*,'(A,A,A)') 'Chosen wavemaker is ',command,' method'
!
IF ( command == 'Boudet' ) THEN
   WRITE(*,'(A,A,A)') 'Chosen wavemaker is ',command,' method'
   STOP 'Not correctly implemented (see definition2.f90)'
   !  
!    CALL assert(wave%dimension == '3D','Boudet''s method: 2D case not implemented')
!    CALL assert(PRESENT(contour).AND.PRESENT(n_pts),'Boudet''s method: missing arguments')
!    WRITE(*,'(A)') 'Initialization of Boudet''s method'
!    CALL assert(SIZE(contour,1)==SIZE(n_pts),'Boudet''s method: not matching size of arguments')
!    n_seg = SIZE(contour,1)
!    n_tot = 0
!    DO nbou = 1, n_seg
!       n_tot = n_tot + n_pts(nbou)
!    END DO
!    WRITE(*,'(A,I4,A,I4,A)') 'A total of',n_tot,' points for',n_seg,' segment(s)'
!    CALL assert(n_tot > wave%N(1),'Boudet''s method: not enough points')
!    N = wave%N(1)
!    ! memory allocation
!    ALLOCATE(pos(n_tot,2), Aij(n_tot,0:N), Ci(n_tot), sol(0:N) )
!    ! position vectors
!    n_tmp = 0
!    DO nbou = 1, n_seg
!       CALL assert(n_pts(nbou) /= 0,'Boudet''s method: zero points on a segment')
! !	  ds = SQRT(**2 + **2)
!       dx = ( contour(nbou,3) - contour(nbou,1) ) / (n_pts(nbou)-1)
!       dy = ( contour(nbou,4) - contour(nbou,2) ) / (n_pts(nbou)-1)
!       pos(n_tmp+1:n_tmp+n_pts(nbou), 1) = arth(contour(nbou,1), dx, n_pts(nbou))
!       pos(n_tmp+1:n_tmp+n_pts(nbou), 2) = arth(contour(nbou,2), dy, n_pts(nbou))
!       n_tmp = n_tmp + n_pts(nbou)
!    END DO
!    ! right hand side construction
!    k = get_k(wave, 1)
!    cth = -i*k*COS(wave%angle)
!    sth = -i*k*SIN(wave%angle)
!    DO nbou = 1, n_tot
!       Ci(nbou) = EXP(pos(nbou,1)*cth+pos(nbou,2)*sth)
!    END DO
!    ! Matrix calculation
!    DO nbou = 0, N
!       kmn = k_mn(wave,0,nbou)
!       mu  = mu_n(wave,nbou)
!       DO mbou = 1, n_tot
!          Aij(mbou,nbou) = CMPLX(COS(mu*pos(mbou,2)),0.0_rp,KIND=CP)*&
!                            EXP(-kmn*pos(mbou,1))
!       END DO
!    END DO
!    ! Matrix "inversion"
!    CALL moindres_carres(Aij,Ci,sol,dx)
!    ! memory allocation in wave
!    IF ( ASSOCIATED(wave%a_on) ) THEN
!       DEALLOCATE(wave%a_on)
!       NULLIFY(wave%a_on)
!    END IF
!    ALLOCATE(wave%a_on(0:N))
!    wave%a_on(:) = sol(:)
!    DEALLOCATE(pos,Aij,Ci,sol)
END IF
!
wave%wavemaker = ADJUSTL(command)
IF ( command == 'Dalrymple' ) THEN
   IF ( PRESENT(X_d) ) THEN
      wave%X_d = X_d
   ELSE
      WRITE(*,'(A)') 'X_d is not present for Dalrymple method in select_wavemaker'
      STOP
   END IF
END IF
!
END SUBROUTINE select_wavemaker
!
!
!
SUBROUTINE reference_2D(wave)
!
IMPLICIT NONE
!
TYPE(wave_12)     :: wave
TYPE(wave_12)     :: wave_test
!
wave_test = wave
!
WRITE(*,*) wave_test%dimension
!
wave_test%angle = 0.0_rp / 180.0_rp * PI
!
CALL select_wavemaker(wave_test, 'snake')
!
wave%a_s_2D = a_4m(wave_test,0,0,0,0) + a_4p(wave_test,0,0,0,0) 
!
END SUBROUTINE reference_2D
!
!
!
SUBROUTINE nullify_basin(basin)
!
IMPLICIT NONE
!
TYPE(size_basin) :: basin
!
!
basin%h         = 0.0_rp
basin%L_x       = 0.0_rp
basin%L_y       = 0.0_rp
basin%type      = ''
basin%d         = 0.0_rp
basin%segmented = .FALSE.
basin%N         = 0
basin%L_r       = 0.0_rp
basin%L_l       = 0.0_rp
!
basin%n_temp    = 0 
basin%path      = ''
!
!CALL initialize_basin(basin,0.0_rp,0.0_rp,0.0_rp,0.0_rp,0,0.0_rp,0.0_rp,'',0)
!
END SUBROUTINE nullify_basin
!
!
!
SUBROUTINE nullify_wave12(wave)
!
IMPLICIT NONE
!
TYPE(wave_12)  :: wave
!
CALL nullify_basin(wave%basin)
!
wave%wavemaker = ''
wave%prec      = 0.0_rp
wave%freq      = 0.0_rp
wave%angle     = 0.0_rp
wave%X_d       = 0.0_rp
wave%steepness = 0.0_rp
wave%ampli     = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
wave%n_mod_y   = 0
wave%n_mod_z   = 0
wave%N         = 0
wave%freq2     = 0.0_rp
wave%sumprec      = 0.0_rp
wave%TF_f      = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
wave%a_s_2D    = CMPLX(0.0_rp, 0.0_rp, KIND=CP)
wave%file      = ''
wave%dimension = ''
!
! Arrays
!  
IF ( ASSOCIATED(wave%alpha_m) ) THEN
   WRITE(*,*) SIZE(wave%alpha_m)
   DEALLOCATE(wave%alpha_m)
   NULLIFY(wave%alpha_m)
END IF
!
IF ( ASSOCIATED(wave%mu_n) ) THEN
   DEALLOCATE(wave%mu_n)
   NULLIFY(wave%mu_n)
END IF
!
IF ( ASSOCIATED(wave%k_mn) ) THEN
   DEALLOCATE(wave%k_mn)
   NULLIFY(wave%k_mn)
END IF
!
!
IF ( ASSOCIATED(wave%TF_m) ) THEN
   DEALLOCATE(wave%TF_m)
   NULLIFY(wave%TF_m)
END IF
IF ( ASSOCIATED(wave%TF_mn) ) THEN
   DEALLOCATE(wave%TF_mn)
   NULLIFY(wave%TF_mn)
END IF
!
IF ( ASSOCIATED(wave%Inty_n) ) THEN
   DEALLOCATE(wave%Inty_n)
   NULLIFY(wave%Inty_n)
END IF
!
IF ( ASSOCIATED(wave%a_on) ) THEN
   DEALLOCATE(wave%a_on)
   NULLIFY(wave%a_on)
END IF
!
IF ( ASSOCIATED(wave%a_mn) ) THEN
   DEALLOCATE(wave%a_mn)
   NULLIFY(wave%a_mn)
END IF
!
IF ( ASSOCIATED(wave%beta_m) ) THEN
   DEALLOCATE(wave%beta_m)
   NULLIFY(wave%beta_m)
END IF
!
IF ( ASSOCIATED(wave%gamma_mn) ) THEN
   DEALLOCATE(wave%gamma_mn)
   NULLIFY(wave%gamma_mn)
END IF
!
IF ( ASSOCIATED(wave%al_mn) ) THEN
   DEALLOCATE(wave%al_mn)
   NULLIFY(wave%al_mn)
END IF
!
IF ( ASSOCIATED(wave%a_4p) ) THEN
   DEALLOCATE(wave%a_4p)
   NULLIFY(wave%a_4p)
END IF
!
IF ( ASSOCIATED(wave%a_4m) ) THEN
   DEALLOCATE(wave%a_4m)
   NULLIFY(wave%a_4m)
END IF
!
!IF ( ASSOCIATED(wave%) ) THEN
!   DEALLOCATE(wave%)
!   NULLIFY(wave%)
!END IF
!
!
END SUBROUTINE nullify_wave12
!
!
!
SUBROUTINE assign_wave12(wave2,wave)
!
IMPLICIT NONE
!
TYPE(wave_12), INTENT(OUT)  :: wave2
TYPE(wave_12), INTENT(IN)   :: wave
!
CALL nullify_wave12(wave2)
!
wave2%basin    = wave%basin
!
wave2%wavemaker = wave%wavemaker
wave2%prec      = wave%prec
wave2%freq      = wave%freq
wave2%angle     = wave%angle
wave2%X_d       = wave%X_d
wave2%steepness = wave%steepness
wave2%ampli     = wave%ampli
wave2%n_mod_y   = wave%n_mod_y
wave2%n_mod_z   = wave%n_mod_z
wave2%N         = wave%N
wave2%freq2     = wave%freq2
wave2%sumprec   = wave%sumprec
wave2%TF_f      = wave%TF_f
wave2%a_s_2D    = wave%a_s_2D
wave2%file      = wave%file
wave2%dimension = wave%dimension
!
! Arrays
!
IF ( ASSOCIATED(wave%alpha_m) ) THEN
   ALLOCATE(wave2%alpha_m(0:SIZE(wave%alpha_m)-1))
   wave2%alpha_m = wave%alpha_m
END IF
!
IF ( ASSOCIATED(wave%mu_n) ) THEN
   ALLOCATE(wave2%mu_n(0:SIZE(wave%mu_n)-1))
   wave2%mu_n = wave%mu_n
END IF
!
IF ( ASSOCIATED(wave%k_mn) ) THEN
   ALLOCATE(wave2%k_mn(0:SIZE(wave%k_mn,1)-1,0:SIZE(wave%k_mn,2)-1))
   wave2%k_mn = wave%k_mn
END IF
!
IF ( ASSOCIATED(wave%TF_m) ) THEN
   ALLOCATE(wave2%TF_m(0:SIZE(wave%TF_m,1)-1,2))
   wave2%TF_m = wave%TF_m
END IF
!
IF ( ASSOCIATED(wave%TF_mn) ) THEN
   ALLOCATE(wave2%TF_mn(0:SIZE(wave%TF_mn,1)-1,0:SIZE(wave%TF_mn,2)-1,2))
   wave2%TF_mn = wave%TF_mn
END IF
!
IF ( ASSOCIATED(wave%Inty_n) ) THEN
   ALLOCATE(wave2%Inty_n(0:SIZE(wave%Inty_n)-1))
   wave2%Inty_n = wave%Inty_n
END IF
!
IF ( ASSOCIATED(wave%a_on) ) THEN
   ALLOCATE(wave2%a_on(0:SIZE(wave%a_on)-1))
   wave2%a_on = wave%a_on
END IF
!
IF ( ASSOCIATED(wave%a_mn) ) THEN
   ALLOCATE(wave2%a_mn(0:SIZE(wave%a_mn,1)-1,0:SIZE(wave%a_mn,2)-1,2))
   wave2%a_mn = wave%a_mn
END IF
!
IF ( ASSOCIATED(wave%beta_m) ) THEN
   ALLOCATE(wave2%beta_m(0:SIZE(wave%beta_m)-1))
   wave2%beta_m = wave%beta_m
END IF
!
IF ( ASSOCIATED(wave%gamma_mn) ) THEN
   ALLOCATE(wave2%gamma_mn(0:SIZE(wave%gamma_mn,1)-1,0:SIZE(wave%gamma_mn,2)-1))
   wave2%gamma_mn = wave%gamma_mn
END IF
!
IF ( ASSOCIATED(wave%al_mn) ) THEN
   ALLOCATE(wave2%al_mn(0:SIZE(wave%al_mn,1)-1,0:SIZE(wave%al_mn,2)-1))
   wave2%al_mn = wave%al_mn
END IF
!
IF ( ASSOCIATED(wave%a_4p) ) THEN
   ALLOCATE(wave2%a_4p(0:SIZE(wave%a_4p,1)-1,0:SIZE(wave%a_4p,2)-1,0:SIZE(wave%a_4p,3)-1,0:SIZE(wave%a_4p,4)-1))
   wave2%a_4p = wave%a_4p
END IF
!
IF ( ASSOCIATED(wave%a_4m) ) THEN
   ALLOCATE(wave2%a_4m(0:SIZE(wave%a_4m,1)-1,0:SIZE(wave%a_4m,2)-1,0:SIZE(wave%a_4m,3)-1,0:SIZE(wave%a_4m,4)-1))
   wave2%a_4m = wave%a_4m
END IF
!
!IF ( ASSOCIATED(wave%) ) THEN
!   DEALLOCATE(wave%)
!   NULLIFY(wave%)
!END IF
!
!
END SUBROUTINE assign_wave12
!
!
!
SUBROUTINE nullify_spectrum1(spec)
!
IMPLICIT NONE
!
! Input variables
TYPE(spectrum1), INTENT(OUT)  :: spec
! Local variables
INTEGER                       :: n_w, wbou
!
IF ( ASSOCIATED(spec%wave) ) THEN
   n_w = SIZE(spec%wave)
   DO wbou = 1, n_w
      CALL nullify_wave12(spec%wave(wbou))
   END DO
   DEALLOCATE(spec%wave)
   NULLIFY(spec%wave)
END IF
!
END SUBROUTINE nullify_spectrum1
!
!
!
SUBROUTINE initialise_spectrum1(spec,N)
!
IMPLICIT NONE
!
! Input variables
TYPE(spectrum1), INTENT(OUT) :: spec
INTEGER, INTENT(IN)          :: N
! Local variables
TYPE(wave_12)                :: null_wave
INTEGER                      :: nbou
!
CALL nullify_spectrum1(spec)
!
ALLOCATE(spec%wave(N))
!
CALL nullify_wave12(null_wave)
!
!DO nbou = 1, N
!   spec%wave(nbou) = null_wave
!END DO
!
DO nbou = 1, N
   CALL nullify_wave12(spec%wave(nbou))
END DO
!
END SUBROUTINE initialise_spectrum1
!
!
!
SUBROUTINE check_spectrum1(spec)
!
IMPLICIT NONE
!
! Input variables
TYPE(spectrum1), INTENT(IN) :: spec
! Local variables
INTEGER                  :: mbou, nbou, n_w
REAL(RP), DIMENSION(5,2) :: test
LOGICAL                  :: l_test
!
n_w = SIZE(spec%wave)
!
DO mbou = 1, n_w
   test(1,1) = spec%wave(mbou)%basin%h
   test(2,1) = spec%wave(mbou)%basin%L_x
   test(3,1) = spec%wave(mbou)%basin%L_y
   test(4,1) = spec%wave(mbou)%basin%N
   test(5,1) = spec%wave(mbou)%basin%d
   DO nbou = mbou+1, n_w
      test(1,2) = spec%wave(nbou)%basin%h
      test(2,2) = spec%wave(nbou)%basin%L_x
      test(3,2) = spec%wave(nbou)%basin%L_y
      test(4,2) = spec%wave(nbou)%basin%N
      test(5,2) = spec%wave(nbou)%basin%d
      l_test = (ABS(test(1,1) - test(1,2)) > tiny).OR.(ABS(test(2,1) - test(2,2)) > tiny).OR.&
      (ABS(test(3,1) - test(3,2)) > tiny).OR.(ABS(test(4,1) - test(4,2)) > tiny).OR.&
      (ABS(test(5,1) - test(5,2)) > tiny)
      IF ( l_test ) THEN
         WRITE(*,'(A)') 'waves of different basin in spectrum'
         WRITE(*,*) mbou, spec%wave(mbou)%basin
         WRITE(*,*) nbou, spec%wave(nbou)%basin
         STOP
      END IF
   END DO
END DO
!
END SUBROUTINE check_spectrum1
!
!
!
SUBROUTINE assign_spectrum1(spec2,spec1)
!
IMPLICIT NONE
!
! Input variables
TYPE(spectrum1), INTENT(OUT) :: spec2
TYPE(spectrum1), INTENT(IN)  :: spec1
! Local variables
INTEGER :: n_w, wbou
!
CALL nullify_spectrum1(spec2)
!
IF ( ASSOCIATED(spec1%wave) ) THEN
   n_w = SIZE(spec1%wave)
   CALL initialise_spectrum1(spec2,n_w)
   DO wbou = 1, n_w
      spec2%wave(wbou) = spec1%wave(wbou)
   END DO
ELSE
   WRITE(*,'(A)') 'spectrum 1 is empty in assign_spectrum'
END IF
!
END SUBROUTINE assign_spectrum1
!
!
!
FUNCTION add_wave12_to_spectrum1(spec,wave)
!
IMPLICIT NONE
!
! Input variables
TYPE(wave_12), INTENT(IN)   :: wave
TYPE(spectrum1), INTENT(IN) :: spec
TYPE(spectrum1)             :: add_wave12_to_spectrum1
! Local variables
INTEGER :: n_w, wbou
!
CALL nullify_spectrum1(add_wave12_to_spectrum1)
!
IF ( ASSOCIATED(spec%wave) ) THEN
   n_w = SIZE(spec%wave)
   CALL initialise_spectrum1(add_wave12_to_spectrum1,n_w+1)
   DO wbou = 1, n_w
      add_wave12_to_spectrum1%wave(wbou) = spec%wave(wbou)
   END DO
   add_wave12_to_spectrum1%wave(n_w+1) = wave
ELSE
   n_w = 0
   CALL initialise_spectrum1(add_wave12_to_spectrum1,n_w+1)
   add_wave12_to_spectrum1%wave(n_w+1) = wave
END IF
!
END FUNCTION add_wave12_to_spectrum1
!
!
!
END MODULE definition2
